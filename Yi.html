<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - particles - waves</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>


	<script type="x-shader/x-vertex" id="vertexshader">

			attribute float scale;

			void main() {

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

				gl_PointSize = scale * ( 300.0 / - mvPosition.z );

				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

	<script type="x-shader/x-fragment" id="fragmentshader">

			uniform vec3 color;

			void main() {

				if ( length( gl_PointCoord - vec2( 0.5, 0.5 ) ) > 0.475 ) discard;

				gl_FragColor = vec4( color, 1.0 );

			}

		</script>

	<script type="module">

		import * as THREE from 'https://cdn.skypack.dev/three';

		var Stats = function () {

			var mode = 0;

			var container = document.createElement('div');
			container.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000';
			container.addEventListener('click', function (event) {

				event.preventDefault();
				showPanel(++mode % container.children.length);

			}, false);

			//

			function addPanel(panel) {

				container.appendChild(panel.dom);
				return panel;

			}

			function showPanel(id) {

				for (var i = 0; i < container.children.length; i++) {

					container.children[i].style.display = i === id ? 'block' : 'none';

				}

				mode = id;

			}

			//

			var beginTime = (performance || Date).now(), prevTime = beginTime, frames = 0;

			var fpsPanel = addPanel(new Stats.Panel('FPS', '#0ff', '#002'));
			var msPanel = addPanel(new Stats.Panel('MS', '#0f0', '#020'));

			if (self.performance && self.performance.memory) {

				var memPanel = addPanel(new Stats.Panel('MB', '#f08', '#201'));

			}

			showPanel(0);

			return {

				REVISION: 16,

				dom: container,

				addPanel: addPanel,
				showPanel: showPanel,

				begin: function () {

					beginTime = (performance || Date).now();

				},

				end: function () {

					frames++;

					var time = (performance || Date).now();

					msPanel.update(time - beginTime, 200);

					if (time >= prevTime + 1000) {

						fpsPanel.update((frames * 1000) / (time - prevTime), 100);

						prevTime = time;
						frames = 0;

						if (memPanel) {

							var memory = performance.memory;
							memPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576);

						}

					}

					return time;

				},

				update: function () {

					beginTime = this.end();

				},

				// Backwards Compatibility

				domElement: container,
				setMode: showPanel

			};

		};

		Stats.Panel = function (name, fg, bg) {

			var min = Infinity, max = 0, round = Math.round;
			var PR = round(window.devicePixelRatio || 1);

			var WIDTH = 80 * PR, HEIGHT = 48 * PR,
				TEXT_X = 3 * PR, TEXT_Y = 2 * PR,
				GRAPH_X = 3 * PR, GRAPH_Y = 15 * PR,
				GRAPH_WIDTH = 74 * PR, GRAPH_HEIGHT = 30 * PR;

			var canvas = document.createElement('canvas');
			canvas.width = WIDTH;
			canvas.height = HEIGHT;
			canvas.style.cssText = 'width:80px;height:48px';

			var context = canvas.getContext('2d');
			context.font = 'bold ' + (9 * PR) + 'px Helvetica,Arial,sans-serif';
			context.textBaseline = 'top';

			context.fillStyle = bg;
			context.fillRect(0, 0, WIDTH, HEIGHT);

			context.fillStyle = fg;
			context.fillText(name, TEXT_X, TEXT_Y);
			context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);

			context.fillStyle = bg;
			context.globalAlpha = 0.9;
			context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);

			return {

				dom: canvas,

				update: function (value, maxValue) {

					min = Math.min(min, value);
					max = Math.max(max, value);

					context.fillStyle = bg;
					context.globalAlpha = 1;
					context.fillRect(0, 0, WIDTH, GRAPH_Y);
					context.fillStyle = fg;
					context.fillText(round(value) + ' ' + name + ' (' + round(min) + '-' + round(max) + ')', TEXT_X, TEXT_Y);

					context.drawImage(canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT);

					context.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT);

					context.fillStyle = bg;
					context.globalAlpha = 0.9;
					context.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round((1 - (value / maxValue)) * GRAPH_HEIGHT));

				}

			};

		};


		const SEPARATION = 100, AMOUNTX = 50, AMOUNTY = 50;

		let container, stats;
		let camera, scene, renderer;

		let particles, count = 0;

		let mouseX = 0, mouseY = 0;

		let windowHalfX = window.innerWidth / 2;
		let windowHalfY = window.innerHeight / 2;

		init();
		animate();

		function init() {

			container = document.createElement('div');
			document.body.appendChild(container);

			camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
			camera.position.z = 1000;

			scene = new THREE.Scene();

			//

			const numParticles = AMOUNTX * AMOUNTY;

			const positions = new Float32Array(numParticles * 3);
			const scales = new Float32Array(numParticles);

			let i = 0, j = 0;

			for (let ix = 0; ix < AMOUNTX; ix++) {

				for (let iy = 0; iy < AMOUNTY; iy++) {

					positions[i] = ix * SEPARATION - ((AMOUNTX * SEPARATION) / 2); // x
					positions[i + 1] = 0; // y
					positions[i + 2] = iy * SEPARATION - ((AMOUNTY * SEPARATION) / 2); // z

					scales[j] = 1;

					i += 3;
					j++;

				}

			}

			const geometry = new THREE.BufferGeometry();
			geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
			geometry.setAttribute('scale', new THREE.BufferAttribute(scales, 1));

			const material = new THREE.ShaderMaterial({

				uniforms: {
					color: { value: new THREE.Color(0xffffff) },
				},
				vertexShader: document.getElementById('vertexshader').textContent,
				fragmentShader: document.getElementById('fragmentshader').textContent

			});

			//

			particles = new THREE.Points(geometry, material);
			scene.add(particles);

			//

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);

			stats = new Stats();
			container.appendChild(stats.dom);

			container.style.touchAction = 'none';
			container.addEventListener('pointermove', onPointerMove);

			//

			window.addEventListener('resize', onWindowResize);

		}

		function onWindowResize() {

			windowHalfX = window.innerWidth / 2;
			windowHalfY = window.innerHeight / 2;

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		//

		function onPointerMove(event) {

			if (event.isPrimary === false) return;

			mouseX = event.clientX - windowHalfX;
			mouseY = event.clientY - windowHalfY;

		}

		//

		function animate() {

			requestAnimationFrame(animate);

			render();
			stats.update();

		}

		function render() {

			camera.position.x += (mouseX - camera.position.x) * .05;
			camera.position.y += (- mouseY - camera.position.y) * .05;
			camera.lookAt(scene.position);

			const positions = particles.geometry.attributes.position.array;
			const scales = particles.geometry.attributes.scale.array;

			let i = 0, j = 0;

			for (let ix = 0; ix < AMOUNTX; ix++) {

				for (let iy = 0; iy < AMOUNTY; iy++) {

					positions[i + 1] = (Math.sin((ix + count) * 0.3) * 50) +
						(Math.sin((iy + count) * 0.5) * 50);

					scales[j] = (Math.sin((ix + count) * 0.3) + 1) * 20 +
						(Math.sin((iy + count) * 0.5) + 1) * 20;

					i += 3;
					j++;

				}

			}

			particles.geometry.attributes.position.needsUpdate = true;
			particles.geometry.attributes.scale.needsUpdate = true;

			renderer.render(scene, camera);

			count += 0.1;

		}

	</script>
</body>

</html>